// SPDX-FileCopyrightText: (C) 2025 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

package utils

import (
	"encoding/base64"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"

	infrastructurev1alpha1 "github.com/open-edge-platform/cluster-api-provider-intel/api/v1alpha1"
	clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

var (
	// k3sCloudConfig is actual data["value"] taken from K3S bootstrap secret
	k3sCloudConfig = []byte(`IyMgdGVtcGxhdGU6IGppbmphCiNjbG91ZC1jb25maWcKCndyaXRlX2ZpbGVzOgotICAgcGF0aDogL3Zhci9saWIvcmFuY2hlci9rM3Mvc2VydmVyL3Rscy9zZXJ2ZXItY2EuY3J0CiAgICBvd25lcjogcm9vdDpyb290CiAgICBwZXJtaXNzaW9uczogJzA2NDAnCiAgICBjb250ZW50OiB8CiAgICAgIC0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQogICAgICBNSUlDNmpDQ0FkS2dBd0lCQWdJQkFEQU5CZ2txaGtpRzl3MEJBUXNGQURBVk1STXdFUVlEVlFRREV3cHJkV0psCiAgICAgIGNtNWxkR1Z6TUI0WERUSTFNRFV5TVRFM01qSXlOVm9YRFRNMU1EVXhPVEUzTWpjeU5Wb3dGVEVUTUJFR0ExVUUKICAgICAgQXhNS2EzVmlaWEp1WlhSbGN6Q0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQUxCaQogICAgICBRQ3BQNTRLS2ZlYnZCcHVqcWdxdWdDQXRIZllkNGgwNGlGSHJmMkx5SnpFN2lIcm1lZzR6c0piMDNkbnpxNEJqCiAgICAgIHA5U0w2V3dJdGVieDIwaXVKTnNpcnpHWUhacjdrM05XaXhLNmtMRGpQYUdoQVdrc2c2a0FDNzd2U0U0VlNLWU4KICAgICAgUEZ2MkVjS2Exd3VnQllFbEN2bGtQZ2FUSEx5NnNCWVh6ZWtXZ1NrMXFvY1VXNWs0YTdzWWFsTmY1SzQ4U1ozbgogICAgICByQ0JBUjN1MnlaREVLVXFvcjNvZ0xIU2ltS01UUG9wOVRyMmdDSnkveEptWHYwOUVMSUUwNjMwdmZxVUdtK1kyCiAgICAgIERpbWtqYVlLVC9rTEJ1S3VvdEhISnVKQ0hCeGJaMnFCMzdKbTE4TWREclVKelNXQnV1eGM4K2xaWTY3TFJNS24KICAgICAgZXhBd2c2YnBJSVE1MldSQktOTUNBd0VBQWFORk1FTXdEZ1lEVlIwUEFRSC9CQVFEQWdLa01CSUdBMVVkRXdFQgogICAgICAvd1FJTUFZQkFmOENBUUF3SFFZRFZSME9CQllFRkFxK1VEVVRsTHR0dFZjeEE4RDlpZWNidkhKWU1BMEdDU3FHCiAgICAgIFNJYjNEUUVCQ3dVQUE0SUJBUUJYbStJV0w4eHFEK0xQUlNObDJkVWZLaGVlUE9TUVNXRVptZy9wbC9CbzFhMGQKICAgICAgTk9tNjhvVGo2cmJQalRQZytGZ0R2OGM2aDMxYWdPeDdxVXF6dlVQL0hPWFVKNmU3VmZSRDNRMldYMGFMOXhGZQogICAgICBza1lHS0RxdlYrbjhxOXRIQWRNc25URXNGdVdOM1hCR2VUSXdja2EyNktYU0Y4SjFWZEVIaDUzV0R2cjAxem5PCiAgICAgIGFoY3UrZWhCV2JvOHg4UXhjZkN1cEM4WUtJdnZjejNQV25FaDFSeUU5RzVhenE1dlkrb2ttWVRzdm5Tc3RScm0KICAgICAgeGpvb1UyR1BPaHZDL0NoeFJXSmplbEtqUkZqOWdaNDNCUlVJczBmdDN6STVjMUJoOVZtbHpGeFVBTlJEbUdMaQogICAgICBPcUNiKzBDcktWQktubEZPS2N0Lzh4ZnpqZ1IwWTExZ2xSM3EyQlB2CiAgICAgIC0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KICAgICAgCi0gICBwYXRoOiAvdmFyL2xpYi9yYW5jaGVyL2szcy9zZXJ2ZXIvdGxzL3NlcnZlci1jYS5rZXkKICAgIG93bmVyOiByb290OnJvb3QKICAgIHBlcm1pc3Npb25zOiAnMDYwMCcKICAgIGNvbnRlbnQ6IHwKICAgICAgLS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQogICAgICBNSUlFcEFJQkFBS0NBUUVBc0dKQUtrL25nb3A5NXU4R202T3FDcTZBSUMwZDloM2lIVGlJVWV0L1l2SW5NVHVJCiAgICAgIGV1WjZEak93bHZUZDJmT3JnR09uMUl2cGJBaTE1dkhiU0s0azJ5S3ZNWmdkbXZ1VGMxYUxFcnFRc09NOW9hRUIKICAgICAgYVN5RHFRQUx2dTlJVGhWSXBnMDhXL1lSd3ByWEM2QUZnU1VLK1dRK0JwTWN2THF3RmhmTjZSYUJLVFdxaHhSYgogICAgICBtVGhydXhocVUxL2tyanhKbmVlc0lFQkhlN2JKa01RcFNxaXZlaUFzZEtLWW94TStpbjFPdmFBSW5ML0VtWmUvCiAgICAgIFQwUXNnVFRyZlM5K3BRYWI1allPS2FTTnBncFArUXNHNHE2aTBjY200a0ljSEZ0bmFvSGZzbWJYd3gwT3RRbk4KICAgICAgSllHNjdGeno2VmxqcnN0RXdxZDdFRENEcHVrZ2hEblpaRUVvMHdJREFRQUJBb0lCQUZta0pVNGJ1K0g1TnBGVwogICAgICBLenFRVEF3UHNXZ281ZEErVWJ0ZUR0SHJhSnRGekN0V1FUK013TDFWQWN0R2VUV2FoQy9FOWZlc2Y1MzdNMDlDCiAgICAgIDNab3JmdW1yei9QWmhqcE0zeHhBQUlBdE52bmZFMlNBYWpJa2dHazBiOFBDNGpGazJiNGlmZW1Tdm1YendaVFQKICAgICAgNTloQmxqazIrOXJsaXpaVGZzaExvc2R5TzRSUVBPanVyVzFmYkRON1EwVUEyUUN1Y016UEpHaVh5TnEzQlBvNQogICAgICBoNERRL21GWnA1YXdkWHpLM2lTcDVwUHlnR1JQdHd5WnROMXkxVlM1NlNoRXA1M0MvZDBtdG5xMzYwMDlYUC9CCiAgICAgIFBXZXdwSnhRMkZtUkRKYXVtNlBiUlBlWExPaTRNb0xOYWhwRTUrMjMzWGtEL3NCVEt6M2craVVaYmhEc2ExVjgKICAgICAgbE9LdUMza0NnWUVBMEZXMEMzdWhIVUdxL1JCdkVBbGVsR0ErQWs4cjRkMjlyaVAyZmRzWDYreUorVG53R1VDcQogICAgICB2VE9lWGpXZ0t6aHJsbXFySkc2ZWFxVjdSZlc1czFMc2dFa2tVUUNpSlpaanlicVozWG5yOFNTQ25PeVJiVzlhCiAgICAgIDNCekxFSk9tSU9aV0pCLzVKeUtVVHEzT3R6MjVCRWtFTWRieEk0TmRrNjFydEo5LzVVMkFaYzBDZ1lFQTJMMG8KICAgICAgaGxGQUVxbDhJZFlGUUtNT2NSQkEvaVNFcUFGcW5CYUYrZUNQOHBqTTZQaTBTM2FMQWkxSCs3YzA2MDRkZ2JDbQogICAgICAwYzhHa0tYVUhrcVVpQjVCTjZ5ZkdLYmhra21GZ05FUFNUemZhQ3Jrb0lIcll5bUZ6WVA0aE1ZWnZQMHdPTEFxCiAgICAgIHJKdkh3SHFaelpXa0JJUFdwak50NklRNS9iRUZtK2JCazBBREtSOENnWUVBcUFiSFhJK01oU1VtZkU1WjFReEoKICAgICAgZk5BV2t4UTVwMFNKTEQ4VEdiU3dHWGJBWFFNT2s3OWxOWTNCUitobVV4V0JLR0xGdjI5OFV6VStORkdZUVhvNwogICAgICBCc2gzQXVISTVSbmpSNXM1WjdoaXhDMlhMbXRhYTNIcFRTZm4yMm5LRGpUWCt2RFNxVzZwUUwvTHZseUlzVjBXCiAgICAgIGhmLytvbzdiMVRTRWJyeEprYTR0UlcwQ2dZRUFzdlI4WVdyMDNIUFVhcHVyK3BLbmVmTlJ0b1d3Z29lbzN2ZzUKICAgICAgNXZmajR3c0hKZFUwQ0pyNGEvTzNXNzhKa3NBTTNPaGUxUjE2N2pQOTBJVUQzdUFjT1R2dW9Rd3BkQUFBbXp3QwogICAgICB3eFhmNE1LSnczMkNQWDRyWEdWNjdTWWtXa2N6YVpzTG9UbCsxUTVscjdtK2szdkgzN0xYTFFVQVhOZXRLZXgrCiAgICAgIEtIYlNKVUVDZ1lCVld3Wk5wQVNkbVJoV3pBa1hFTHBqZVB4WEhuTUVBTDZSeVdQaEtUMkZDVVYxakI4VjBlWXMKICAgICAgcmJPTWI2cUtmcU9GRjE1VHBPTEZqejlsb0lpbHBEMG9MT1pmUVBBQzk0NlpSODlmODBpTXpYRW9WOVZxNzNJZAogICAgICBGc04rejR6d3k3bTNia2x0ei9pS2dxUXRMMDlDa3BGZmptalNuV0lhOGlyOGVXNmc1NHN0ZUE9PQogICAgICAtLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQogICAgICAKLSAgIHBhdGg6IC92YXIvbGliL3JhbmNoZXIvazNzL3NlcnZlci90bHMvY2xpZW50LWNhLmNydAogICAgb3duZXI6IHJvb3Q6cm9vdAogICAgcGVybWlzc2lvbnM6ICcwNjQwJwogICAgY29udGVudDogfAogICAgICAtLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KICAgICAgTUlJQzZqQ0NBZEtnQXdJQkFnSUJBREFOQmdrcWhraUc5dzBCQVFzRkFEQVZNUk13RVFZRFZRUURFd3ByZFdKbAogICAgICBjbTVsZEdWek1CNFhEVEkxTURVeU1URTNNakl5TlZvWERUTTFNRFV4T1RFM01qY3lOVm93RlRFVE1CRUdBMVVFCiAgICAgIEF4TUthM1ZpWlhKdVpYUmxjekNDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFLNncKICAgICAgbUxoNHhsU21YelRYcHJDRnYrT1JQZWNiT2JiVzhZR0lFYlI0RDJmUEVyMy9JSzJLUHVwQXp2S2xVQVExeTY3bwogICAgICBla1pBQlh1WjRQSExLSWRxY0E4WTA0VHNHbU4wUk5ZY0FjUEJkQ3gwQzZDaVdHY1lVRkJqTkFPalBzV3hNZDJXCiAgICAgIDRMRHhGcDd5ZWJjUDdkNUdKcHF2TGltTDh3TjVMdHFrVnVrMmg0TnJZM0V1eWpoZzVvbkdoM3lCdTlBaWJwUysKICAgICAgaDBXNkxxTHF1T0pCK0J4ZnUvWC9SSHVTNVlmbVdYVHEyckgxTE9BVTRoWUUyVHR4Ymp2c3lOYzFoZ1I0NFp2TwogICAgICArQTB6dTFUMVFvaDBrTGxQR2RDbkZDVk90VTBSMmZPd0ZwYmZ1Z2cxYU5CNzVEM0w5c0hnajlVRmlxN25RSzZ0CiAgICAgIGlhaWFUMVRaT1RBSC9LMjUxRFVDQXdFQUFhTkZNRU13RGdZRFZSMFBBUUgvQkFRREFnS2tNQklHQTFVZEV3RUIKICAgICAgL3dRSU1BWUJBZjhDQVFBd0hRWURWUjBPQkJZRUZJcUMrU0MxU0FPYmlWMzBkam5MY3JycENYWmJNQTBHQ1NxRwogICAgICBTSWIzRFFFQkN3VUFBNElCQVFCaWd5RmVhWHVJUzg1SVBMTzl3eTA2aGpjVldRdlZRY1c0ZXdUMkhaa0h1U0tZCiAgICAgIGlpZmt6V2JmS0RoNVQ2bUJ6RDJKRE85bGNLVTFQc3hVTk9NSkhXSGd3SU1RRGlOellVdzFTVWxGa2dkbkorWisKICAgICAgRjhyUSs1YXBobklUNzNzejRSSW0ySzZJRG1mZktEMm44ckluRXNpUyt4Q2FtditROFAvZlBKNEhLR2toVnJUeQogICAgICAwMUxKMXhnQnNkZmppTkNoZVFQSWp2eEVFdjBPZ1Z4a1NpREdIenNYOXpEYWVpNDBKYmR1eFRjWDFSbkxueklmCiAgICAgIEVVaVM1aXIreEFEdnhWcm1kNDh3Vll3b1FnclhCTXByUXBSQWxhZlVVcmZ3U2FkRXZoZ3Fidm1YNnVoejByWFcKICAgICAgN2VGMW5pK3FnNmxSR2ZlWWlESURNR1hJVW53MSs2VGtld0VyaUp5QQogICAgICAtLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCiAgICAgIAotICAgcGF0aDogL3Zhci9saWIvcmFuY2hlci9rM3Mvc2VydmVyL3Rscy9jbGllbnQtY2Eua2V5CiAgICBvd25lcjogcm9vdDpyb290CiAgICBwZXJtaXNzaW9uczogJzA2MDAnCiAgICBjb250ZW50OiB8CiAgICAgIC0tLS0tQkVHSU4gUlNBIFBSSVZBVEUgS0VZLS0tLS0KICAgICAgTUlJRXBRSUJBQUtDQVFFQXJyQ1l1SGpHVktaZk5OZW1zSVcvNDVFOTV4czV0dGJ4Z1lnUnRIZ1BaODhTdmY4ZwogICAgICByWW8rNmtETzhxVlFCRFhMcnVoNlJrQUZlNW5nOGNzb2gycHdEeGpUaE93YVkzUkUxaHdCdzhGMExIUUxvS0pZCiAgICAgIFp4aFFVR00wQTZNK3hiRXgzWmJnc1BFV252SjV0dy90M2tZbW1xOHVLWXZ6QTNrdTJxUlc2VGFIZzJ0amNTN0sKICAgICAgT0dEbWljYUhmSUc3MENKdWxMNkhSYm91b3VxNDRrSDRIRis3OWY5RWU1TGxoK1paZE9yYXNmVXM0QlRpRmdUWgogICAgICBPM0Z1Tyt6STF6V0dCSGpobTg3NERUTzdWUFZDaUhTUXVVOFowS2NVSlU2MVRSSFo4N0FXbHQrNkNEVm8wSHZrCiAgICAgIFBjdjJ3ZUNQMVFXS3J1ZEFycTJKcUpwUFZOazVNQWY4cmJuVU5RSURBUUFCQW9JQkFRQ1dqYmh4ZEJWcUt5RHUKICAgICAgaDlVdldYWXhpS0dUSmhHdGxMMzdadXZyWDNYWGY4MmxWZFl4K20yU3Nsd3BIM1JBektSSWtDK2hqOWVwMk1yWAogICAgICBXTUlMUXg1a3hINjNsa3gvM2xyZE5MSUlwaGVib0QvTkoxMk5MSlU3VXVRbkpuQVpMVWZPdEJQZUswblZueUJyCiAgICAgIE54MUliYWtqczByVG43dkhDSS9xKzZ1enZyMDM4czd3azVKOTF2Nm9TWnlOYTFSNy9rSjNrTkRrWEhPdDFoVzcKICAgICAgNkRnbENlNnJad3ZuaUxSUzFldndRbFVCMjJrVlhPKzBPMitCTzZBU1Fta3FrbHVWVExXS1N0WnZsQWtUcCs4TQogICAgICBWS3NHRVdiaVczeVFWRFdzOW5sU1hPOUpJT2pLWElhZmJ5Mk9YSGFHQzJRemJjY09kMkFEektvOXVsaEljNGxXCiAgICAgIC9RcHVYU3JaQW9HQkFORzBhbkZRUVAvR3lSaTN0QTY5WFJkQTYrTzVUR2FTODZ3ZWhQWWlja1NYeDlLbUxqSFAKICAgICAgY1N3ZTdUcFB4QXNSK3hrMFpLQ29UZDQ0R2ZmeUpkK01oZDkvSEZjWnc5VDNyNUROaXBpeTU4NFBVbXcxYlc4WQogICAgICB3dEZFOFh2UG16emJBV0ZPKzVCOWtnVnJOaEE2STdNc0Vmd2NYQ2xmT2tTb0lMRklmc01waTZMUEFvR0JBTlZCCiAgICAgIFN1Uk1vMGp0azBucVlMQ2pqUkNGMWpWVlBHeGNkdGtNdk5YVEtDNDN3OHh6dkRKTGYwN2RyQVRrd29scjlLWjUKICAgICAgbWdvN2Q4QTJrMGg5NHlqTGxJRG9EbnE0L25Xay8ybFJyQ2llUmhpZkhrbytaV1RwSWlUQXFpRDByblVPeXplYwogICAgICA5YVlaRWhsSTg0aGdST0hNYmJNdk5YNFV1VlNNcXh0WGN1SHFuV203QW9HQkFLRmZOSW4rT0FhYjhpUVRPWHdlCiAgICAgIFBJU29jTjNNdWY0MUYwNWNMZlU2akxROEdJa0JXSXI4RnhyY3NiRXRzSzdVSjJZOTZ6RzJVald1OWt6WENrMzgKICAgICAgMVFnbnlLYytMSFMySldSSXgxNjZUYWRFSXlraDlCU0orV0VRck1PWi90dlZyRG8xaldDalFMcnF4YSszRGNIVAogICAgICBLQVBaenhJSE5jK2ZrWWpiUUxEdVI0WUJBb0dCQU0xR3ZYMkhYQUkrVm5KblAwMnBFWWZmSFBSWHFRTXgrbUV5CiAgICAgIFJxK1pRK3RCV0tOOG9LTFZVNldwOGdULzQxYis2UkE2cTVHLzdxVENwQUc2MUNnWDEwcENsbldCajhmVTNOc1gKICAgICAgZUIzZFJPSThnSjY4ODBNd3V1SWY1MlF6dzU4QWI1T0g3bHBGZGN1TEVvbXJDWU5GRWkvU2VLNTE2blE5dUJObwogICAgICBtVGhvYThBekFvR0FIdlluaHlyRFRKc2JPSzRLa0lBT0JtMjJXcldGWWM3K09nL1M0TytrVWtuUmVicGFxQUllCiAgICAgIElvaDRKRWtjbldVeis4ZC9zcW9DQXAyNUZhTFA2L0FER2IrTkpDVHhYRTBQNTJFYktIWmZKVnArTEg2dlBpWXAKICAgICAga0ZZZFpDb2RNR2xhQlU0eXV2WjJIVm10eGxkME1Ub0RJMGk5aGxycDNaUS9pMkpwTnRvZFhGWT0KICAgICAgLS0tLS1FTkQgUlNBIFBSSVZBVEUgS0VZLS0tLS0KICAgICAgCi0gICBwYXRoOiAvdmFyL2xpYi9yYW5jaGVyL2szcy9zZXJ2ZXIvdGxzL2V0Y2Qvc2VydmVyLWNhLmNydAogICAgb3duZXI6IHJvb3Q6cm9vdAogICAgcGVybWlzc2lvbnM6ICcwNjQwJwogICAgY29udGVudDogfAogICAgICAtLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KICAgICAgTUlJQzZqQ0NBZEtnQXdJQkFnSUJBREFOQmdrcWhraUc5dzBCQVFzRkFEQVZNUk13RVFZRFZRUURFd3ByZFdKbAogICAgICBjbTVsZEdWek1CNFhEVEkxTURVeU1URTNNakl5TlZvWERUTTFNRFV4T1RFM01qY3lOVm93RlRFVE1CRUdBMVVFCiAgICAgIEF4TUthM1ZpWlhKdVpYUmxjekNDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFMSVMKICAgICAgVEo4UStyYWF5RVpwRXhFbXpJaHRiRk00Wm52QUNSSGF0RXdldlg1dUdxbUdyZ1lydVJ3TThwUkdkaG04a2RhNwogICAgICBDeGZJTHBkMkZYRXFuTlFIT2VTY21NNEg1czFaVGh3dHlXL2MrWDBvcEJJZzZ6YWV1NmFnUDBLUzFvc0dtV3VOCiAgICAgIDViYnJ3aUxMb2JMSjhpUHJONVJ5RkhBckRLNkNEaVpJOTJuNjdjdnJGSjdvUzdqUmpHTiszL09WNUtJNEg2WnoKICAgICAgemlNL2ptUFE4SkFaTW5Zb3JlMHA2ZSs2Y3RxRmNybmE2RXllblZoL2ZJbUoxQUYwVFlUdTh6Z0NpRTFscjFhcQogICAgICBpa0lPbk5iRTEzaWRLMTJLRjdpMzN6UlROMUR0b2xiUnRtcHVrWUZWOE1WNEREMnByL1hha0pIdStQS1NwaFhWCiAgICAgIHVMUXEyTEF5Z1YzMERoR0ZVRzBDQXdFQUFhTkZNRU13RGdZRFZSMFBBUUgvQkFRREFnS2tNQklHQTFVZEV3RUIKICAgICAgL3dRSU1BWUJBZjhDQVFBd0hRWURWUjBPQkJZRUZHdHJTdzZnaCszVWRVZWdkRHUzQTRyMjkwdS9NQTBHQ1NxRwogICAgICBTSWIzRFFFQkN3VUFBNElCQVFBSUdocy9XMVRiWWoweHlib1dpR0w1SnAxQ2syeGZzb0lYVDlPRkxyZ1JUbS9ECiAgICAgIFhqNGNsYlJaYVVtcWl5QjI2UmFwVDJxazU3YldiSzhWRGdoYlNCUHNKcjhvVm83ZmN5ZUlNejdGOTQ2RXF1aUsKICAgICAgSHRpcEJ0YlFYNUpVV0drM0ZlZ0VsOUhEQTlwSVB4RHBobGJXWkFVY0M5MExiWXgzNFVtSDVIVU5CVTh2VW91TgogICAgICBzZ3hoRHhxaGIxM2ZRQVdXM0t0RSs3NXlHN0hLaXM0ZGYzTDZBMnhzWWphOVByQUdsVXJqQkhvTXIweWcxRFRpCiAgICAgIGwvV2lOWUJXZnFHamZDcldEMnlCVit0b3U5QVIrZ3lreGRrRHR1Tjdjd05lOWpHcVNUYVBJRFowRU1iQmtYQmIKICAgICAgYXJmOXg0ZGJ6c25nOFFkeFJVUUpLWGtxMEcvanBZWDMvUWs5VkRvdQogICAgICAtLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCiAgICAgIAotICAgcGF0aDogL3Zhci9saWIvcmFuY2hlci9rM3Mvc2VydmVyL3Rscy9ldGNkL3NlcnZlci1jYS5rZXkKICAgIG93bmVyOiByb290OnJvb3QKICAgIHBlcm1pc3Npb25zOiAnMDYwMCcKICAgIGNvbnRlbnQ6IHwKICAgICAgLS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQogICAgICBNSUlFb2dJQkFBS0NBUUVBc2hKTW54RDZ0cHJJUm1rVEVTYk1pRzFzVXpobWU4QUpFZHEwVEI2OWZtNGFxWWF1CiAgICAgIEJpdTVIQXp5bEVaMkdieVIxcnNMRjhndWwzWVZjU3FjMUFjNTVKeVl6Z2ZtelZsT0hDM0piOXo1ZlNpa0VpRHIKICAgICAgTnA2N3BxQS9RcExXaXdhWmE0M2x0dXZDSXN1aHNzbnlJK3MzbEhJVWNDc01yb0lPSmtqM2FmcnR5K3NVbnVoTAogICAgICB1TkdNWTM3Zjg1WGtvamdmcG5QT0l6K09ZOUR3a0JreWRpaXQ3U25wNzdweTJvVnl1ZHJvVEo2ZFdIOThpWW5VCiAgICAgIEFYUk5oTzd6T0FLSVRXV3ZWcXFLUWc2YzFzVFhlSjByWFlvWHVMZmZORk0zVU8yaVZ0RzJhbTZSZ1ZYd3hYZ00KICAgICAgUGFtdjlkcVFrZTc0OHBLbUZkVzR0Q3JZc0RLQlhmUU9FWVZRYlFJREFRQUJBb0lCQUh4Zmg2QzZMVUtKVFVUUQogICAgICBjdjdSeUoycFA3WEllTndLUHN0M28rSmV2aCttSzMwb2tqZkJKaU5QYjhiY2gvUmwzcjdLR1c5YzVCM3AzZ1FTCiAgICAgIHJVTHlZUjhwdVJoK01GaFEvZHQwcDNNNE5oR1M1elc2UkU3OEF6allTQmJwbEd1NkNrSXk4N1VWYVp6LytVcDAKICAgICAgL21qVUN4ZmxyaHpDRkxOMkp3ZmFndVJFM1A1Rll2cWFyZmlKenVIdUFxaG5abUphWlkvSVkrazIramgxMkIyaQogICAgICBnQkJhcmxDSmNOL0JCb3VadUpUOHJLSFQrcEZmdU13bVVqNlNxTmlLVXd4aHV1YUVsNFZxaDdueGRvTTFhL3RGCiAgICAgIFkvdkNOb29haEt4MFdjQlNreGU5dlNmVExWSGw1SkdRVEdSejdEaWljeHZibjBQNjVrbWhUOGdVTjhyMXNMWHIKICAgICAgZjBVMmI4RUNnWUVBMWRyd2EreC8zNDhGZEhNbUhmQUs0Rm5jY1ZqNi9qbDIzWEl5dWpOVElVOWtQUmRXTVlaWQogICAgICBqQjJMTVl2OGQzRDRZZkFSR1gxV0swbklUSU5pbDlxU1JFaURreVF1Y3JRUktQYTR4UkpkYUZISjBMVzcvdk9ICiAgICAgIDFiQksxR2NxODBodTFCVGlJNmdUcG01bzVyUVhiWmhnNnRZNnpqbytUMHZDTjlrczVlblhsMGtDZ1lFQTFTb1AKICAgICAgS0xLYTVkMmhVSjd6TmhUY2J1engvUHB3TmpGODNvUEx0RzhHQXdkNXQrODdsVnh6ZXNlTURNeUNSSHBLSkgvUgogICAgICBOc2ZmcllFN2FlQWUwYkxSLzFjR1ZNVHg5VDlOcEZNbTVxRGRYaTdsZVJ1eDZFanRNNnFKckpnQmJYNGlNTkM2CiAgICAgIFFBY0pxQ1ZkNDZNcnB2WElOOW5KYXJoY1huSHVYQXM1cE5MSWZBVUNnWUFraHdMdHpEV0RQL0NVbFY1N1dwYmcKICAgICAgL3poUisvclRGWW1pQlhGNHNHK1FqdmoySGxoUW1UdmlvdUUxazAyS01UZWJzdCtZMVBtMDV5TlpQay9HMUVTTAogICAgICBlVDlRRUt3R1Y0OWV5ZFdCZzhPRW9BT3lySGZ4OGpMUFl3OUUvR0l2cjcyT2FBckFRR01xMkV6K3F1QWRqaHR2CiAgICAgIHdTdkdNZGlXdnIvcnZpS1hHcndDVVFLQmdDOW5NUVBONUNCbUR1K015VzBuYW5YSWYyL1FpWStqcGE4ZUEvalcKICAgICAgRDdJd3dXS2o4czRlUnhmd3REWk1iRk9xRmo3VHBjVFc0ZWtGcWg2N1ZsOHZzdjlqYk9jQS9RV2ExRHRNdW9QagogICAgICBGaGRSdW5vYUxKQUpWNlo3c0M0UGg1Ry8wUDZtRENVYzY0clc5SEFnNHg0MzNoUjlmQXNkZ0gwSVBRZCsvNHlsCiAgICAgIHl5dTVBb0dBRjN1bCtySEdKSFNhVjJSMkIyVlY1dXBnRHdNb3FCLy9wZjhOZzV3dGNEZUl4cDhraEI5UUt6ZksKICAgICAgSUttdVZpcXpNVEpiYzRMUFU3LzR4ZlR6U2c2UDlJV2RUdCtneGY2MkM2WkIvVll4YWdnTmxqZDR5b0UzQVdNSQogICAgICA1WGc4VFpIWWtpU3pZN1ZDR1VjN0Z3RjdlRmM0NXQwT2ZqVHl5RG5GdW50REdWaGpRZ2s9CiAgICAgIC0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCiAgICAgIAotICAgcGF0aDogL3Zhci9saWIvcmFuY2hlci9rM3Mvc2VydmVyL21hbmlmZXN0cy9ldGNkLXByb3h5LnlhbWwKICAgIG93bmVyOiByb290OnJvb3QKICAgIHBlcm1pc3Npb25zOiAnMDY0MCcKICAgIGNvbnRlbnQ6IHwKICAgICAgYXBpVmVyc2lvbjogYXBwcy92MQogICAgICBraW5kOiBEYWVtb25TZXQKICAgICAgbWV0YWRhdGE6CiAgICAgICAgbmFtZTogZXRjZC1wcm94eQogICAgICAgIG5hbWVzcGFjZToga3ViZS1zeXN0ZW0KICAgICAgICBsYWJlbHM6CiAgICAgICAgICBhcHA6IGV0Y2QtcHJveHkKICAgICAgc3BlYzoKICAgICAgICBzZWxlY3RvcjoKICAgICAgICAgIG1hdGNoTGFiZWxzOgogICAgICAgICAgICBhcHA6IGV0Y2QtcHJveHkKICAgICAgICB0ZW1wbGF0ZToKICAgICAgICAgIG1ldGFkYXRhOgogICAgICAgICAgICBsYWJlbHM6CiAgICAgICAgICAgICAgYXBwOiBldGNkLXByb3h5CiAgICAgICAgICBzcGVjOgogICAgICAgICAgICBub2RlU2VsZWN0b3I6CiAgICAgICAgICAgICAgbm9kZS1yb2xlLmt1YmVybmV0ZXMuaW8vZXRjZDogInRydWUiCiAgICAgICAgICAgIHRvbGVyYXRpb25zOgogICAgICAgICAgICAtIGtleTogbm9kZS1yb2xlLmt1YmVybmV0ZXMuaW8vY29udHJvbC1wbGFuZQogICAgICAgICAgICAgIG9wZXJhdG9yOiBFeGlzdHMKICAgICAgICAgICAgICBlZmZlY3Q6IE5vU2NoZWR1bGUKICAgICAgICAgICAgLSBrZXk6IG5vZGUtcm9sZS5rdWJlcm5ldGVzLmlvL21hc3RlcgogICAgICAgICAgICAgIG9wZXJhdG9yOiBFeGlzdHMKICAgICAgICAgICAgICBlZmZlY3Q6IE5vU2NoZWR1bGUKICAgICAgICAgICAgY29udGFpbmVyczoKICAgICAgICAgICAgLSBuYW1lOiBldGNkLXByb3h5CiAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgaW1hZ2U6IGFscGluZS9zb2NhdDoxLjguMC4wCiAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgZW52OgogICAgICAgICAgICAgIC0gbmFtZTogSE9TVElQCiAgICAgICAgICAgICAgICB2YWx1ZUZyb206CiAgICAgICAgICAgICAgICAgIGZpZWxkUmVmOgogICAgICAgICAgICAgICAgICAgIGZpZWxkUGF0aDogc3RhdHVzLmhvc3RJUAogICAgICAgICAgICAgIGFyZ3M6IAogICAgICAgICAgICAgIC0gVENQNC1MSVNURU46MjM3OSxmb3JrLHJldXNlYWRkcgogICAgICAgICAgICAgIC0gVENQNDokKEhPU1RJUCk6MjM3OQogICAgICAgICAgICAgIHJlc291cmNlczoKICAgICAgICAgICAgICAgIGxpbWl0czoKICAgICAgICAgICAgICAgICAgbWVtb3J5OiAyMDBNaQogICAgICAgICAgICAgICAgcmVxdWVzdHM6CiAgICAgICAgICAgICAgICAgIGNwdTogMTAwbQogICAgICAgICAgICAgICAgICBtZW1vcnk6IDIwME1pCiAgICAgICAgICAgICAgdm9sdW1lTW91bnRzOgogICAgICAgICAgICAgIC0gbmFtZTogdmFybG9nCiAgICAgICAgICAgICAgICBtb3VudFBhdGg6IC92YXIvbG9nCiAgICAgICAgICAgIHRlcm1pbmF0aW9uR3JhY2VQZXJpb2RTZWNvbmRzOiAzMAogICAgICAgICAgICB2b2x1bWVzOgogICAgICAgICAgICAtIG5hbWU6IHZhcmxvZwogICAgICAgICAgICAgIGhvc3RQYXRoOgogICAgICAgICAgICAgICAgcGF0aDogL3Zhci9sb2cKICAgICAgCi0gICBwYXRoOiAvZXRjL3JhbmNoZXIvazNzL2NvbmZpZy55YW1sCiAgICBvd25lcjogcm9vdDpyb290CiAgICBwZXJtaXNzaW9uczogJzA2NDAnCiAgICBjb250ZW50OiB8CiAgICAgIGNsdXN0ZXItZG9tYWluOiBjbHVzdGVyLmVkZ2UKICAgICAgY2x1c3Rlci1pbml0OiB0cnVlCiAgICAgIGt1YmUtYXBpc2VydmVyLWFyZzoKICAgICAgLSBhbm9ueW1vdXMtYXV0aD10cnVlCiAgICAgIC0gdGxzLWNpcGhlci1zdWl0ZXM9VExTX0VDREhFX0VDRFNBX1dJVEhfQUVTXzI1Nl9HQ01fU0hBMzg0LFRMU19FQ0RIRV9SU0FfV0lUSF9BRVNfMjU2X0dDTV9TSEEzODQsVExTX0VDREhFX0VDRFNBX1dJVEhfQUVTXzEyOF9HQ01fU0hBMjU2LFRMU19FQ0RIRV9SU0FfV0lUSF9BRVNfMTI4X0dDTV9TSEEyNTYsVExTX0VDREhFX0VDRFNBX1dJVEhfQ0hBQ0hBMjBfUE9MWTEzMDUsVExTX0VDREhFX1JTQV9XSVRIX0NIQUNIQTIwX1BPTFkxMzA1LFRMU19SU0FfV0lUSF9BRVNfMTI4X0dDTV9TSEEyNTYsVExTX1JTQV9XSVRIX0FFU18yNTZfR0NNX1NIQTM4NAogICAgICBrdWJlLWNvbnRyb2xsZXItbWFuYWdlci1hcmc6CiAgICAgIC0gY2xvdWQtcHJvdmlkZXI9ZXh0ZXJuYWwKICAgICAga3ViZWxldC1hcmc6CiAgICAgIC0gY2xvdWQtcHJvdmlkZXI9ZXh0ZXJuYWwKICAgICAgdGxzLXNhbjoKICAgICAgLSBjbHVzdGVyLWNvbm5lY3QtZ2F0ZXdheS5kZWZhdWx0LnN2YwogICAgICB0b2tlbjogMTZjYTU5MjQxMGNhY2MwMzFkODc2OWNmYTRkOTQ3MjAKICAgICAgCnJ1bmNtZDoKICAtICBjdXJsIC1zZkwgaHR0cHM6Ly9nZXQuazNzLmlvIHwgSU5TVEFMTF9LM1NfVkVSU0lPTj12MS4zMC4yK2szczIgc2ggLXMgLSBzZXJ2ZXIgICYmIG1rZGlyIC1wIC9ydW4vY2x1c3Rlci1hcGkgJiYgZWNobyBzdWNjZXNzID4gL3J1bi9jbHVzdGVyLWFwaS9ib290c3RyYXAtc3VjY2Vzcy5jb21wbGV0ZQo=`) //nolint:lll
)

func GetObjectRef(obj *metav1.ObjectMeta, kind string) *corev1.ObjectReference {
	return &corev1.ObjectReference{
		APIVersion: infrastructurev1alpha1.GroupVersion.String(),
		Kind:       kind,
		Name:       obj.Name,
		Namespace:  obj.Namespace,
		UID:        obj.UID,
	}
}

func NewCluster(namespace, clusterName string) *clusterv1.Cluster {
	cluster := &clusterv1.Cluster{
		TypeMeta: metav1.TypeMeta{},
		ObjectMeta: metav1.ObjectMeta{
			Name:      clusterName,
			Namespace: namespace,
		},
	}
	return cluster
}

func NewIntelCluster(namespace, intelClusterName, providerId string, cluster *clusterv1.Cluster) *infrastructurev1alpha1.IntelCluster { //nolint:lll
	return &infrastructurev1alpha1.IntelCluster{
		TypeMeta: metav1.TypeMeta{},
		ObjectMeta: metav1.ObjectMeta{
			Name:      intelClusterName,
			Namespace: namespace,
			OwnerReferences: []metav1.OwnerReference{
				{
					APIVersion: clusterv1.GroupVersion.String(),
					Kind:       "Cluster",
					Name:       cluster.Name,
					UID:        cluster.UID,
				},
			},
		},
		Spec: infrastructurev1alpha1.IntelClusterSpec{
			ProviderId: providerId,
		},
	}
}

func NewNamespace(name string) *corev1.Namespace {
	return &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: name,
		},
	}
}
func NewIntelClusterNoSpec(cluster *clusterv1.Cluster) *infrastructurev1alpha1.IntelCluster {
	return &infrastructurev1alpha1.IntelCluster{
		TypeMeta: metav1.TypeMeta{},
		ObjectMeta: metav1.ObjectMeta{
			Name:      cluster.Name,
			Namespace: cluster.Namespace,
			OwnerReferences: []metav1.OwnerReference{
				{
					APIVersion: clusterv1.GroupVersion.String(),
					Kind:       "Cluster",
					Name:       cluster.Name,
					UID:        cluster.UID,
				},
			},
		},
	}
}

func NewMachine(namespace, clusterName, machineName, bootstrapKind string) *clusterv1.Machine {
	bootstrapData := "bootstrap-data"
	machine := &clusterv1.Machine{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Machine",
			APIVersion: clusterv1.GroupVersion.String(),
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      machineName,
			Namespace: namespace,
			Labels: map[string]string{
				clusterv1.ClusterNameLabel:         clusterName,
				clusterv1.MachineControlPlaneLabel: "true",
			},
			UID: types.UID("1234567890"),
		},
		Spec: clusterv1.MachineSpec{
			ClusterName: clusterName,
			Bootstrap: clusterv1.Bootstrap{
				ConfigRef: &corev1.ObjectReference{
					Kind: bootstrapKind,
				},
				DataSecretName: &bootstrapData,
			},
		},
	}
	return machine
}

func NewIntelMachine(namespace, intelMachineName string, machine *clusterv1.Machine) *infrastructurev1alpha1.IntelMachine { //nolint:lll
	return &infrastructurev1alpha1.IntelMachine{
		TypeMeta: metav1.TypeMeta{
			Kind:       "IntelMachine",
			APIVersion: infrastructurev1alpha1.GroupVersion.String(),
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      intelMachineName,
			Namespace: namespace,
			OwnerReferences: []metav1.OwnerReference{
				{
					APIVersion: clusterv1.GroupVersion.String(),
					Kind:       "Machine",
					Name:       machine.Name,
					UID:        machine.UID,
				},
			},
			Labels: map[string]string{infrastructurev1alpha1.NodeGUIDKey: ""},
		},
	}
}

func NewIntelMachineBinding(namespace, intelMachineBindingName, nodeGUID, clusterName, machineTemplateName string) *infrastructurev1alpha1.IntelMachineBinding { //nolint:lll
	return &infrastructurev1alpha1.IntelMachineBinding{
		TypeMeta: metav1.TypeMeta{},
		ObjectMeta: metav1.ObjectMeta{
			Name:      intelMachineBindingName,
			Namespace: namespace,
		},
		Spec: infrastructurev1alpha1.IntelMachineBindingSpec{
			NodeGUID:                 nodeGUID,
			ClusterName:              clusterName,
			IntelMachineTemplateName: machineTemplateName,
		},
	}
}

func NewIntelMachineTemplate(namespace, name, parent string) *infrastructurev1alpha1.IntelMachineTemplate { //nolint:lll
	annotations := map[string]string{}
	if parent != "" {
		annotations[clusterv1.TemplateClonedFromNameAnnotation] = parent
	}
	return &infrastructurev1alpha1.IntelMachineTemplate{
		TypeMeta: metav1.TypeMeta{},
		ObjectMeta: metav1.ObjectMeta{
			Name:        name,
			Namespace:   namespace,
			Annotations: annotations,
		},
		Spec: infrastructurev1alpha1.IntelMachineTemplateSpec{},
	}
}

/* func NewRKE2BootstrapSecret(namespace, secretName string) *corev1.Secret {
	value, err := base64.StdEncoding.DecodeString(string(rke2CloudConfig))
	if err != nil {
		panic(err)
	}

	return &corev1.Secret{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Secret",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      secretName,
			Namespace: namespace,
		},
		Data: map[string][]byte{
			"format": []byte("cloud-config"),
			"value":  value,
		},
	}
} */

func NewK3SBootstrapSecret(namespace, secretName string) *corev1.Secret {
	value, err := base64.StdEncoding.DecodeString(string(k3sCloudConfig))
	if err != nil {
		panic(err)
	}

	return &corev1.Secret{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Secret",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      secretName,
			Namespace: namespace,
		},
		Data: map[string][]byte{
			"value": value,
		},
	}
}
