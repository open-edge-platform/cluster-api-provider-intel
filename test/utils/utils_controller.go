// SPDX-FileCopyrightText: (C) 2025 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

package utils

import (
	"encoding/base64"

	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	infrastructurev1alpha1 "github.com/open-edge-platform/cluster-api-provider-intel/api/v1alpha1"
	clusterv1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

var (
	// rke2CloudConfig is actual data["value"] taken from RKE2 bootstrap secret
	rke2CloudConfig = []byte(`IyMgdGVtcGxhdGU6IGppbmphCiNjbG91ZC1jb25maWcKCndyaXRlX2ZpbGVzOgotICAgcGF0aDogL2V0Yy9yYW5jaGVyL3JrZTIvcmVnaXN0cmllcy55YW1sCiAgICBvd25lcjogcm9vdDpyb290CiAgICBwZXJtaXNzaW9uczogJzA2NDAnCiAgICBjb250ZW50OiB8CiAgICAgIGNvbmZpZ3M6IG51bGwKICAgICAgbWlycm9yczoge30KICAgICAgCi0gICBwYXRoOiAvdmFyL2xpYi9yYW5jaGVyL3JrZTIvc2VydmVyL3Rscy9zZXJ2ZXItY2EuY3J0CiAgICBvd25lcjogcm9vdDpyb290CiAgICBwZXJtaXNzaW9uczogJzA2NDAnCiAgICBjb250ZW50OiB8CiAgICAgIC0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLQogICAgICBNSUlDNmpDQ0FkS2dBd0lCQWdJQkFEQU5CZ2txaGtpRzl3MEJBUXNGQURBVk1STXdFUVlEVlFRREV3cHJkV0psCiAgICAgIGNtNWxkR1Z6TUI0WERUSTFNREV5TkRFM05UUXdOMW9YRFRNMU1ERXlNakUzTlRrd04xb3dGVEVUTUJFR0ExVUUKICAgICAgQXhNS2EzVmlaWEp1WlhSbGN6Q0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU9xbQogICAgICBUdEd4dEpRc0FEWk1FckhrQjRVMW1XSlE3L1lhTjFza3N3RWZoZXlDUlpFM1lqcG9HT3Q1ZmtSbEZjU200dXhtCiAgICAgIDlaQmpUcFZGQndIUS92eWM2Vk5tdzFOdGpFZmlITEdCUFFXS3hTbWlYcnU1RDF6cGZXUkRRcklqNkx4aHlrVEwKICAgICAgYmFFRnE5RHo0RHNlWUxiL1U0RTc0WDdDbTdwWHo4Um5McVlwRWNWcThOejJPVVFqQW5EVGRHa2ZTc0Z0N2traQogICAgICA3MXlkbnRrb2FjUVFvTS9sMkZmWmQyak1FeXA0RVdBNjEycXUvQkF4Uzc0T09rRE5RbUFBWE5JTUo2SFFHNzBsCiAgICAgIEg1ZS9pSzduRFZzZWFsQysyYkdVeWxEdmNsajdRWm5FZWpKdzc2a1dPT2s3RFRETkNRMjE1R2FESUk1UExkZVAKICAgICAgcVk2czdnNzNxK0RlOTlSYUN2c0NBd0VBQWFORk1FTXdEZ1lEVlIwUEFRSC9CQVFEQWdLa01CSUdBMVVkRXdFQgogICAgICAvd1FJTUFZQkFmOENBUUF3SFFZRFZSME9CQllFRks0dUUxSlI5RW9VRzdYem5JWWNrVVQ2SkVheU1BMEdDU3FHCiAgICAgIFNJYjNEUUVCQ3dVQUE0SUJBUUFMQjYzeEFBNitidWFtc0orUjVOcWJUUEtOTXA4NXlscFgzYXNlTngwR0ZTQTAKICAgICAgZFlndGhjSTc1aXlONW9GY0sxdUlsT0traGJ2Y2FNeFY1MmdXVDk1bE5MVWFnazFUano5aWJ5bCtiU0Q4b2JtVQogICAgICByVjNXV0RjM3JMcXY5U1AwYVZIUllIeXkxVSt1NnFlb1VLY0c5RWVGczB1VTh1N3ltUHZoVEIrQWRpRllKZkRQCiAgICAgIGxLZ1Q0NFJSaTRLZzJ6T1pZUE16M2JMUGlNb05MRUduS2l5L3JkZWhzcy9PU1EzdnVYdWxLSXp4SHJia2ZCRU0KICAgICAgQTMwTzFHcm1iRi95TWlZZDBVbFdEWWJJY1BnRmNQUmZGS2tJb1haRnZXNVgzakwrakxSS2Q1bzRQaXROSWgxYgogICAgICB2YmFjTXZLL2NZUVM5dWFzVDJrNHlmSlllL3Y1N0pINVFJVURUZ1E1CiAgICAgIC0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0KICAgICAgCi0gICBwYXRoOiAvdmFyL2xpYi9yYW5jaGVyL3JrZTIvc2VydmVyL3Rscy9zZXJ2ZXItY2Eua2V5CiAgICBvd25lcjogcm9vdDpyb290CiAgICBwZXJtaXNzaW9uczogJzA2MDAnCiAgICBjb250ZW50OiB8CiAgICAgIC0tLS0tQkVHSU4gUlNBIFBSSVZBVEUgS0VZLS0tLS0KICAgICAgTUlJRW93SUJBQUtDQVFFQTZxWk8wYkcwbEN3QU5rd1NzZVFIaFRXWllsRHY5aG8zV3lTekFSK0Y3SUpGa1RkaQogICAgICBPbWdZNjNsK1JHVVZ4S2JpN0diMWtHTk9sVVVIQWREKy9KenBVMmJEVTIyTVIrSWNzWUU5QllyRkthSmV1N2tQCiAgICAgIFhPbDlaRU5Dc2lQb3ZHSEtSTXR0b1FXcjBQUGdPeDVndHY5VGdUdmhmc0tidWxmUHhHY3VwaWtSeFdydzNQWTUKICAgICAgUkNNQ2NOTjBhUjlLd1czdVNTTHZYSjJlMlNocHhCQ2d6K1hZVjlsM2FNd1RLbmdSWURyWGFxNzhFREZMdmc0NgogICAgICBRTTFDWUFCYzBnd25vZEFidlNVZmw3K0lydWNOV3g1cVVMN1pzWlRLVU85eVdQdEJtY1I2TW5EdnFSWTQ2VHNOCiAgICAgIE1NMEpEYlhrWm9NZ2prOHQxNCtwanF6dUR2ZXI0TjczMUZvSyt3SURBUUFCQW9JQkFDNFdUQlRUbW13ZjJFclIKICAgICAgMWpvcVYyL0tmejNZTjhsV2pOalI5SGFjQW1uWmpHQmhTR0hBWUdTZmtEVk94Vi9DaDM5M0dYUXFqUnkwV2hQNQogICAgICBRSnZORmViVG9EbWFvcHJieGxiMjAwMXJYQjQ1VGZJQS93dDRzTEFvcGNqblZLYnJiaGJrL2J0S3FkeDRpZW9TCiAgICAgIHBWeEwrZExBT0NIMWh6Q3FYcHhzeDdUTEREcUJ6bEJFUnB0WU5nMWs5ZG1malpTbjVIWkpud2xlWGFTaEI1dXAKICAgICAgcGNyUWpFTDdZMmR1UTUyWUdoLy9GTXhRcDJOZkVXT3AwM3gvUWtBK3FBdWpLUGZtdGVZdUZZT0dTeVZxMTQ5cAogICAgICA3TzNRQVF3OS9vL29wWWV6WVNLUUdrV1plREJrOXYwemxFVmhPWXhZV1NxdUpER0w5S3NlVE43eEl2UlBCQ2FECiAgICAgIHJDWVgyMEVDZ1lFQTc5NnVEeWU2UURoZ1MveUVYaDIwd01TYTR0WDB5OU1QbW9EN0dlZGN0SHpKMUFBcTFYQ0oKICAgICAgUHoyZVhacVB3eDluT1paMUN3eU1JT3hVS2VicnZLTjc0bnVDV2VsZzdObTNCcTc5eUVsUEN4YjVxWFNRWEVVRgogICAgICBkTEg2UU41cEZLRExuNlVkd1FvM0lNY0xUTWNiNjBYMnBGMzcrSzVybGFGN002QktHT21RakwwQ2dZRUErbTNECiAgICAgIFZZM2Y1b3RJbk1JWW9oZzlEYnVlc2UrUHRKTS8zWHo1TFdjT3BjWTVySlNyTkVNcXBtRWRrdUpQaEVhOG5JV1EKICAgICAgeE12VHNQbDJRYXRydmZ4RVcxM2dsekRDalprK3VVMXVNSmVsbTNKZkZ3bTdhd2g4aTdhYUUvdjRvQ0JmZENiSgogICAgICB2Ty9uT3pmVTlyVU9JYmdJM0dNVmhWWUlXUjFxek1sQm14cHdYaGNDZ1lBanBUakNnY25ZdjBmNElzZGM0UmM2CiAgICAgIFNqMG1GbHR4YXFUMzlkRGEwWm5pTEdVbHZ2eWVpVUdzQnpFZ2dkWjVUWkplYVhCdE91a2IvMkttYzIxMnMraTIKICAgICAgQ0ZxZmwrSFNjS3dWTHk0QmRIdHRqM1Y4YkJrRHpUSDVYSFZ1N0Y0N05ZWHM3SEdXZlRraUF0STRENktqZk5zaAogICAgICBJK0pNMjBhYmpzcXJLbGU0aWdUMEZRS0JnSG5haU82TFAwUTl4OUpHKzVkNzlkRkYxdDA3OVEvbmltN3FqWkNUCiAgICAgIEVlU0dCTEErRXVRMlBuMkF5ZFFiL0pjZm1FME5ETGxGZUxjblcyeHV6ZGsrODhBRmVPLzRVT0ozaTdhOHYzNHoKICAgICAgZStpY2lUcDdpTTkyN0t0SzZjUUptaHZJUk1vT3lhRCtsdVFRc2JadHVQZWRSZXArNkF6ZUpPZS8wYVRkMU9kMAogICAgICB3UEozQW9HQkFOR0RxZURyT3dzUjBrakR3NmlZTXBCb1lVMVdqYWt0WTBzRFo1M2dCRS9HYS8zUElmUU5NR20zCiAgICAgIEtZRkVEYnlESGF4NW9nTXhqNnpPQ24rVCtKOUpxUURnSWs4OEpPZ3lCeUcvZ3cxTUZEVzZPRVNicGlXZGZFVVoKICAgICAgdytmVjdNNE9ZUlkycW1JVmxkbjMvSHJaa01vZWRVVG9BSjZnRXhZUGExS3o1cXgyNldETQogICAgICAtLS0tLUVORCBSU0EgUFJJVkFURSBLRVktLS0tLQogICAgICAKLSAgIHBhdGg6IC92YXIvbGliL3JhbmNoZXIvcmtlMi9zZXJ2ZXIvdGxzL2NsaWVudC1jYS5jcnQKICAgIG93bmVyOiByb290OnJvb3QKICAgIHBlcm1pc3Npb25zOiAnMDY0MCcKICAgIGNvbnRlbnQ6IHwKICAgICAgLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCiAgICAgIE1JSUM2akNDQWRLZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKICAgICAgY201bGRHVnpNQjRYRFRJMU1ERXlOREUzTlRRd04xb1hEVE0xTURFeU1qRTNOVGt3TjFvd0ZURVRNQkVHQTFVRQogICAgICBBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBS2s3CiAgICAgIExoVXdwSkkyS01QWjdhaGd1MzFRenhMWFp1T0tuTjhCK1NMOUw3enhBL3pvWkphdFEzQVZmemJmRjFscFVCWFQKICAgICAgalJtYmt6MDBjY203OXRvOWl1QW8yZTFHVnh1YXdBbUp2SjN2MkNudTNYWVY0Z25GUHRuaU1PYjZmdU9QYm0vdwogICAgICBKLzdwKzVGN3p1cUVnVmFWSFNHQUNEZUJKM1piaFJISEdINEt3SFFLMkdPUGpCZTJPWDBNZ21yWkJxK2prT09ICiAgICAgIDFURHEraUxhZzJTNDc1d0IzNDUxd0dnTUk4ZWpTbnBaM0FVOUlOZEFoaENTL01hdS9KaUJJQkYyMmVrRmFZZ0YKICAgICAgYzBhUkhreFN5Uit2eHNvVFN5cFpUMjYvbkVoK0hxYmh1ZURuOUtiNDZ4MllnbjlPc1J3TzhGT1RXL2VrWVVkNgogICAgICBQNGMxUldsZFlrUTZDbXhXVWhNQ0F3RUFBYU5GTUVNd0RnWURWUjBQQVFIL0JBUURBZ0trTUJJR0ExVWRFd0VCCiAgICAgIC93UUlNQVlCQWY4Q0FRQXdIUVlEVlIwT0JCWUVGSzdZR3BYL2hkK2p1dXV5YnBITDlBWmUvZnNXTUEwR0NTcUcKICAgICAgU0liM0RRRUJDd1VBQTRJQkFRQkVqMFhoZXFkZHEvSExRL0V0bmNPcUx5UEFhQWhzVE9QWDZkcm9SbXdSNEpFSgogICAgICBFYmI3SUp5bzkxUHh5ZjdFMW1KZkpOWVR4RXQwMmIrRkJmRkxTZncybE5xWS8wT2QvMis4TDNFc1d3WE5LWkRXCiAgICAgIDN2Tk5kUG55ZDFRdWE5alhiM0tIMHZsak1mdy9QbVlqSXFWVXhKQkkvTnpKdGxLUUhzOGdGVlZRcEhpc2RkK3YKICAgICAgVTNqNlhqLzJFNktEN05aeTBZYlpQZVZlTE9CaFNXTGYybnF2bzhkYVgzblFpS0lPNkVSTEoxN29tUUtEY1hkQQogICAgICBLc2FNbnVydkx3K0YreWtPeWp1REZveFpnaTlRcUplZnJqSzRucVNkTmxPMXE5SkwrM2t3cGgwNDdwYitlQlZGCiAgICAgIEJYczhCUXhNMHBZQWh2ZG91SmlLamp6aWtTZXZ4a2pmQTIrSVMzRVUKICAgICAgLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQogICAgICAKLSAgIHBhdGg6IC92YXIvbGliL3JhbmNoZXIvcmtlMi9zZXJ2ZXIvdGxzL2NsaWVudC1jYS5rZXkKICAgIG93bmVyOiByb290OnJvb3QKICAgIHBlcm1pc3Npb25zOiAnMDYwMCcKICAgIGNvbnRlbnQ6IHwKICAgICAgLS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQogICAgICBNSUlFb3dJQkFBS0NBUUVBcVRzdUZUQ2trallvdzludHFHQzdmVkRQRXRkbTQ0cWMzd0g1SXYwdnZQRUQvT2hrCiAgICAgIGxxMURjQlYvTnQ4WFdXbFFGZE9OR1p1VFBUUnh5YnYyMmoySzRDalo3VVpYRzVyQUNZbThuZS9ZS2U3ZGRoWGkKICAgICAgQ2NVKzJlSXc1dnArNDQ5dWIvQW4vdW43a1h2TzZvU0JWcFVkSVlBSU40RW5kbHVGRWNjWWZnckFkQXJZWTQrTQogICAgICBGN1k1ZlF5Q2F0a0dyNk9RNDRmVk1PcjZJdHFEWkxqdm5BSGZqblhBYUF3ang2TktlbG5jQlQwZzEwQ0dFSkw4CiAgICAgIHhxNzhtSUVnRVhiWjZRVnBpQVZ6UnBFZVRGTEpINi9HeWhOTEtsbFBicitjU0g0ZXB1RzU0T2YwcHZqckhaaUMKICAgICAgZjA2eEhBN3dVNU5iOTZSaFIzby9oelZGYVYxaVJEb0tiRlpTRXdJREFRQUJBb0lCQUJMRDJDbExXb1JIOHg4OAogICAgICBkQWplcVF1TlFWamlmNnN0ZkpXUjMzRk14OVZZbUV1YjdVTno5TzFoeE5odHhtWUlzbk9wSUpVOVZnZE1ZRzJ4CiAgICAgIEpQOHdJYzBYV29yZjZOckx2dzJQczFXRCtlRTBkbVFZcXhiUVExYmZxUEtEeGp3dmRGeC9NY0FuYTlqRzlMdTIKICAgICAgYzYwSkhkRFFKSmthL2lnMm43dkg2dVJYQnQ0WEEzckdnU0RpUUhvd1VCZVRsUVl4TjI1RXhnTGtKTlhqclJoSgogICAgICBhbklvc1BMekRmWkdIQWErL1YvbW9ZVWhEMDdKR1ptVk1kbkNic2JHUTBsWUd1eXhYSndnSjRwbFZkclVHd054CiAgICAgIGR3czJ0MnpVZlBWakp6TElobHp4bFcyTWR3Njh3SGlHVnJORjc3V0hQMFhrNkp2L3htZUJrZGVUQXpPb3p3ZE4KICAgICAgbTljdWV0RUNnWUVBNEgvN0xyZFp3ckpKdGt6ZXR3TTRwaWJMWmFzaDJLdHVZcVZpTWtHTXp3SFV4d0lkdFFndgogICAgICBBUTljZ1ZRQUF2MjN0cmViVkJIVUlrMmNsOWhkZlJpNmtmaExUaUR6MmY5RGdITzRVVUdmN2JtKzJTWmpxUjB2CiAgICAgIDJpYi96RnoySGVKOVowcEVuMk0zVVJtQzlPSGtUSER3UUdJTThQMHdqQ0R1SVNqa3V6UXkrUmtDZ1lFQXdQbnoKICAgICAgSVhtL090cW44YU4zbUZzMWoyanNEYjRBOE92bkNiNjQwcmRpRzdxcjNOb2xLbnRKdWppVUhUcDNNUmJzQ0cxNgogICAgICBLWnM3L2UrTHVJaThOZi95QmJGT3RsWVhrWlc4WmdoSUhRMWZsR2srYTEzUEZyZFlnNEZtTWVOR1ZEVFVtVHYxCiAgICAgIDlrbU1RdVU5SmthcUUyZU1lNnNPTndCK2xadmFmNkhQY0dCQVRnc0NnWUFJek51Q3pFc25kNmV1RHJ0WVB6Y1UKICAgICAgUkVjSzJEZCtiOUhtNmdhOFk1ZHFjZTd1VWlYcDk4VW43SHM2MHBraGhPS1R0Z1RQdWRjdjlRempZdWJmUlgzaQogICAgICB4UEhtd1NIdDlMU25yMkdWUmRaSUVsVHAzRGhoNDdRQmdDL2N5ZlFYM2MzK280bW5HZE9NU1V5NTNyVDlUaHdNCiAgICAgIDJnc1owMEw0NnoyS2JUanlJYXl4MlFLQmdRQy94Q01OOHhSTGdobytrRGs2bC9qanFGcGJWYU5OeHI5eSthcGwKICAgICAgQzROZEZ1WE90S0VXVkNueCttT0ZvQ0h1RUY5Q0NMakxPODRrRExZR0RTc3Jaa3ExeVhyMHl4emt1YTNjbndJNgogICAgICBqSjJjdC9FbGRMVmtWNUtJTEVESDlwaGUrWmtESllqSTFGR2o4SFlSNFVzRnVYTHJPaE1JS1YraGdKMWpGQU0yCiAgICAgIEl4QUQvUUtCZ0hGM3NraWZCeXJNb1FMMEVoN3pIeWJzbGpiYkpuOE1FdWRXM2hvbEQzNmR4YUlhU3ZBSXZEYloKICAgICAgVWJ5QkdoTUlHVTJlYXFSSlpDMTUzQWZVcy8vazhFR05oa0VLSVZHV3d2WGRrbWF3c2M0MWVkeFJGZ1BGTk8vdgogICAgICB1VElQSmVZZFgyaHQ5NExjc3VzQnZxTnJXaldLTldkWnZETE5PSFZuN3oxbEJxRjExaHJiCiAgICAgIC0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCiAgICAgIAotICAgcGF0aDogL3Zhci9saWIvcmFuY2hlci9ya2UyL3NlcnZlci90bHMvZXRjZC9wZWVyLWNhLmNydAogICAgb3duZXI6IHJvb3Q6cm9vdAogICAgcGVybWlzc2lvbnM6ICcwNjQwJwogICAgY29udGVudDogfAogICAgICAtLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS0KICAgICAgTUlJQzZqQ0NBZEtnQXdJQkFnSUJBREFOQmdrcWhraUc5dzBCQVFzRkFEQVZNUk13RVFZRFZRUURFd3ByZFdKbAogICAgICBjbTVsZEdWek1CNFhEVEkxTURFeU5ERTNOVFF3TjFvWERUTTFNREV5TWpFM05Ua3dOMW93RlRFVE1CRUdBMVVFCiAgICAgIEF4TUthM1ZpWlhKdVpYUmxjekNDQVNJd0RRWUpLb1pJaHZjTkFRRUJCUUFEZ2dFUEFEQ0NBUW9DZ2dFQkFLVnUKICAgICAgL2RKek5MdFh4YmtSU1BLR2dpajMvVEY4RDFMVXBVL1dRTjUxcU1OcHJPYm1LSFhCL2pGamhZTXNkMjlVanJCYwogICAgICA2czhwd0wvcmJQdWNYUmJYc0x0NkYzM3A1ODd3a3AyOHp5ZEdab1JHK2ZaODN5djFZdi9pT1Z1Vjhld0oyYzJqCiAgICAgIHF1Lzd2RWJ4WWo2eUVSYXZiTDRseU5sYkJPYUtyb0hHVzVBMmhaMVdvRG9vNU1zS1ZWNHhYbmw5ZG04ZFZOZksKICAgICAgTEdYVzM5aWZwWnZwdG40SUc2NS9pMmFEZ1VyU00zNHB0MW9zUnBEMFZrS0gveHdEMGRSR3N4RlNVN1c1U1ZuSwogICAgICBZVEcxM2h1WmpralRuUnJmU2c5ckxOUjhUOFJJREpLRUw3S3poZEtBVWYybTk0Qkd3bzZ3SnRTTHFxUDd4dVU4CiAgICAgIE45a3ZQc2FLdll6U0svOVpsVDBDQXdFQUFhTkZNRU13RGdZRFZSMFBBUUgvQkFRREFnS2tNQklHQTFVZEV3RUIKICAgICAgL3dRSU1BWUJBZjhDQVFBd0hRWURWUjBPQkJZRUZGdyt1OVFPMW5aVCsvMzRUWXJJRjZPNnFkenlNQTBHQ1NxRwogICAgICBTSWIzRFFFQkN3VUFBNElCQVFBblg4K1JZakEwNytUS2tOMmNwZGNiVUd2cS9yR2UxenV6WCtvY2IzMVcvdU1QCiAgICAgIDZsYjh6c3JlSHFqYVVJNU1tMU5UdlB1NEZLbXFmR2hRekZERElBVUdUNXFMVS9pN1ZvWjV6dklMdUx0S3h3K24KICAgICAgMTZjdG5FWXFCcWdBWE1YUDF4elRkd2d0Uno5aGlIR29jN2o4amFsTHk3Ti95c2g0WUozK3V3aU9qMnV6L3FJMgogICAgICBaalNvaE1SZlNzMytJQkdnQXkxRWV4bjUxZ3NOMFN1eDZWVzA2MWZ1b3U4NUFuOU5aRU1uRmVjc09HNmN0b0cxCiAgICAgIFhRWHVQMllObXJBQXVBTjdmMUZicURSczNMcWNnVzY3TVMyb3JPT014cm4wVHpFV3B3Y0RlZkxMbnd5OXdBR0YKICAgICAgSjlsZ2tFVzhNMlRPVG9HZFhUd2Vmd053SGRLdVRlN3c3Qi9vc09MaAogICAgICAtLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCiAgICAgIAotICAgcGF0aDogL3Zhci9saWIvcmFuY2hlci9ya2UyL3NlcnZlci90bHMvZXRjZC9wZWVyLWNhLmtleQogICAgb3duZXI6IHJvb3Q6cm9vdAogICAgcGVybWlzc2lvbnM6ICcwNjAwJwogICAgY29udGVudDogfAogICAgICAtLS0tLUJFR0lOIFJTQSBQUklWQVRFIEtFWS0tLS0tCiAgICAgIE1JSUVvd0lCQUFLQ0FRRUFwVzc5MG5NMHUxZkZ1UkZJOG9hQ0tQZjlNWHdQVXRTbFQ5WkEzbldvdzJtczV1WW8KICAgICAgZGNIK01XT0ZneXgzYjFTT3NGenF6eW5Bdit0cys1eGRGdGV3dTNvWGZlbm56dkNTbmJ6UEowWm1oRWI1OW56ZgogICAgICBLL1ZpLytJNVc1WHg3QW5aemFPcTcvdThSdkZpUHJJUkZxOXN2aVhJMlZzRTVvcXVnY1pia0RhRm5WYWdPaWprCiAgICAgIHl3cFZYakZlZVgxMmJ4MVUxOG9zWmRiZjJKK2xtK20yZmdnYnJuK0xab09CU3RJemZpbTNXaXhHa1BSV1FvZi8KICAgICAgSEFQUjFFYXpFVkpUdGJsSldjcGhNYlhlRzVtT1NOT2RHdDlLRDJzczFIeFB4RWdNa29RdnNyT0Ywb0JSL2FiMwogICAgICBnRWJDanJBbTFJdXFvL3ZHNVR3MzJTOCt4b3E5ak5Jci8xbVZQUUlEQVFBQkFvSUJBR1h5Q2RSZ1RrU01pRG5OCiAgICAgIG53aGxQMXlEeGJGeTQvYUZPQUlFNUNDeW5QY2U3ZiswSVlhL3J5YzhUeEJRbktFc21HbXlPTGpFNEJUa3ZWb28KICAgICAgTjIxV0tZQytjaStUcnRmbGhGUlQvOHdTSkNhcm5tbjQ5WVlmUjR5c0dmQ0liSGFxYzErMzFpVGhHbHNWY1JkMQogICAgICBuL1k4MEdRMDRKcWc3bG9yWi9KdERBdklyWG9RNURPbExmMG9zMmFFZndZWTcvY3VWMGkyWTlDUitITGRoYVVyCiAgICAgIFZ3STFXQ2NFa0RKYXBzVGxtYThhSk11ZWl1K2wxbnN1L1B3R2tpS2VBWEFGTHBEbjdXbjhGRldlODB1L3lnQjQKICAgICAgNDJoU2huMVd1UmMwUHk1Nm80NUhKVmJUeXZCZ1cxS1NQUjkrTzJDN2g4emlQWTZkTXB2NEVOcjludDV0NmpySgogICAgICBzWWRyMTNrQ2dZRUF6R29ISUh1UW5FT1JVOGdvY1VneE80bEdYNjRyTDNMck5MWk92SVg2L0FTY09weDltWUFsCiAgICAgIEhpY0NKRVN1WE9nZ3NHTzB3SmlnQzhWMjZ3bXIwb3dTazNXQzV3dU80OENLY3N2ZVlZR1MwVjRnQzlDcnFMczYKICAgICAgd0t2Zms1V0RCMGoyUS8yS1FOTnVHZDVwN3I3UUgrZlRjYzAvZGVkWmJNcm95QkZ4YTUwRHp2TUNnWUVBenk2cAogICAgICBFK3lNSFdPbUxqL3hnQVh1M0JFaHRaTWNFZThVaFpIYythZWx0YkJTMjg1NjhFQWxISnpydkpSV0JubC9BdFJICiAgICAgIDNXdlpvd2pkYkJRaVRGV1d2MC9RZUV6TVhXb2MrbkxQWjBkREVua3pKeDBDZjZRcURKaDMxYkkxU2JWWVZiWksKICAgICAgL1MxbTRsUHBha3hwUEZzMDZkOFBjN0VDNXlSQ2REUVJDNGU4OXc4Q2dZQTZVNWF0QWhVRlFaSmFJYWJJakJ6ZwogICAgICBMQTlVaGRIMHZBbTVCTHY2dHhBaWtQNHpDeXdiZktFYXRXNjdBbzN1SEo0WE5wd0F5SXdDVDluYXZ1dTBMQnV3CiAgICAgIHo3c0dTaG4vaXBUMnBJMVRyVEZEWkdRb2V1WkFRd3hFcGNZcHltT1UxSkRRWGF2eFMyTURKcDk3YkI3ZXU3dHQKICAgICAgb1c4V0tXa3V6Y2NXTDBQNXZOZTFXUUtCZ0RjbFVGUEJUcm96My9QSGlWeHVOOW5UcFlsVEV0R2pOVzhvR0ExTAogICAgICBsa3Y2RnRQeTdiNHRGTE85QVBJOCtYalh0ZnJtemdvZHZ0d3FhK1ZzcG9SeTg2RVFlWWpMeUVuRkNObVEzYXU3CiAgICAgIHlCcU9zQkxsSWRrZnRTR05JN2g1cXIxbnk0OWs2aWpoZ05VVlNMZkdodXhOeXBQRmo3TlhsbEkzMElobG8zUFMKICAgICAgT1hYNUFvR0JBTENJSXhzOWlmcDZKbytJU1dUNnRjWnhwNmNWZmlUczVkUVRuQXQvZ0hHeHZWdUxFTzFMU0xGZwogICAgICBCcXBrYldHMUJMRkhBZzdJcC90N2VYN0RtNkNNSzhXUTFrcmlNMTM5dHBMakRac1pNTlN0c0JIKzJxRU00MDRTCiAgICAgIG5STml6WDc4NmNCeWVLSkh5TGdoLzZOaUdFY0hON2RYeVA5TDJJVVA2RjF6L0gvV21CdUYKICAgICAgLS0tLS1FTkQgUlNBIFBSSVZBVEUgS0VZLS0tLS0KICAgICAgCi0gICBwYXRoOiAvdmFyL2xpYi9yYW5jaGVyL3JrZTIvc2VydmVyL3Rscy9ldGNkL3NlcnZlci1jYS5jcnQKICAgIG93bmVyOiByb290OnJvb3QKICAgIHBlcm1pc3Npb25zOiAnMDY0MCcKICAgIGNvbnRlbnQ6IHwKICAgICAgLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCiAgICAgIE1JSUM2akNDQWRLZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKICAgICAgY201bGRHVnpNQjRYRFRJMU1ERXlOREUzTlRRd04xb1hEVE0xTURFeU1qRTNOVGt3TjFvd0ZURVRNQkVHQTFVRQogICAgICBBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTFd4CiAgICAgIElsbnRNVjdYdUdPaGF1ZkF1dEV2YlNMRWEwYmtpMGxiMWh6U1dGcWRuOFhQWE9CK0Q4ODVUWjJ6OVdlZVFBTGgKICAgICAgaksyekt2cVVmeHNxSUEyc01ZNlZ6cGFSdllIQzBDUERTeE9Rb0VreGxkWTdJb1RiQW9CdlE2UWZQR2FsNlp5dQogICAgICAvMEFTbG0zbnZPb3JLMXJXWWhCRjQyMGt6UkRZU3BkK3hYRkxzcFliQkppVDFUT25IWjIwZGorYm5sZlBwWDNOCiAgICAgIFhWTjlBNE41YlRac0xzV0JSaXZBanN6djUrWEJwYUlDYm5LWjNqZmJrUHJlUHNKRHlXTWxGWTVwL0cvOTF2Rm8KICAgICAgR3ZRR0NxNzR0NDF2WmV6OWNtUEtZOXJaRnVNYzY0N3MwNWowcUhObGNYWXpmN1lBakUrWldnZ3ZHNkhTRlZvUwogICAgICBzbmkyYmh1dFg5KzN2RjZyKzM4Q0F3RUFBYU5GTUVNd0RnWURWUjBQQVFIL0JBUURBZ0trTUJJR0ExVWRFd0VCCiAgICAgIC93UUlNQVlCQWY4Q0FRQXdIUVlEVlIwT0JCWUVGS2Nua2JqMkFtNk8zNWRsS0llNzJnUXFqRnBGTUEwR0NTcUcKICAgICAgU0liM0RRRUJDd1VBQTRJQkFRQm80WkpMOUN3RkVES2c0N1FKMUFJelhRT011djNGZVhMWTY4ZTVhUmJFWE5leAogICAgICBOVzFmTEsvMk50RzMxM2pMZFJoSFAzd0lPQjIyVjdRbGs4bitYZlNTMHpERUhpcTBsZ1BxMnlqZ1lsUCs3N3VsCiAgICAgIC85YyszTVpMSmpDaWlVQi94UGsyazJ6WHg0WXpnQVE1L0JPYlY3cDB6dS90TU9uYitxT1ZDRFlXejRxZ0VTVm4KICAgICAgWjhSMWx1TjJydTRnZm9QR1hKejBBKzZ3bDRzaWFBZjNjQk9KVFBBdFlkdWh0aDlJNm1UempMSnV0Ym8rQ2d2QQogICAgICAxZDk5aGx6TFVDQ29wRHQxRkhCNWYxYlNNTlZ1VmtXeGd5YTBjd1ZERFJpTTJiYmFhdDMzSW9wYUxWWXpGTjFnCiAgICAgIEwyeG1NVFV5YzRTZ0hsSHhNNGJ3MVljOGU0ckMwWUZ5T2V4enNOQTAKICAgICAgLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLQogICAgICAKLSAgIHBhdGg6IC92YXIvbGliL3JhbmNoZXIvcmtlMi9zZXJ2ZXIvdGxzL2V0Y2Qvc2VydmVyLWNhLmtleQogICAgb3duZXI6IHJvb3Q6cm9vdAogICAgcGVybWlzc2lvbnM6ICcwNjAwJwogICAgY29udGVudDogfAogICAgICAtLS0tLUJFR0lOIFJTQSBQUklWQVRFIEtFWS0tLS0tCiAgICAgIE1JSUVvZ0lCQUFLQ0FRRUF0YkVpV2UweFh0ZTRZNkZxNThDNjBTOXRJc1JyUnVTTFNWdldITkpZV3AyZnhjOWMKICAgICAgNEg0UHp6bE5uYlAxWjU1QUF1R01yYk1xK3BSL0d5b2dEYXd4anBYT2xwRzlnY0xRSThOTEU1Q2dTVEdWMWpzaQogICAgICBoTnNDZ0c5RHBCODhacVhwbks3L1FCS1diZWU4Nmlzcld0WmlFRVhqYlNUTkVOaEtsMzdGY1V1eWxoc0VtSlBWCiAgICAgIE02Y2RuYlIyUDV1ZVY4K2xmYzFkVTMwRGczbHRObXd1eFlGR0s4Q096Ty9uNWNHbG9nSnVjcG5lTjl1USt0NCsKICAgICAgd2tQSll5VVZqbW44Yi8zVzhXZ2E5QVlLcnZpM2pXOWw3UDF5WThwajJ0a1c0eHpyanV6VG1QU29jMlZ4ZGpOLwogICAgICB0Z0NNVDVsYUNDOGJvZElWV2hLeWVMWnVHNjFmMzdlOFhxdjdmd0lEQVFBQkFvSUJBQVpkaGs2UU9NS1IzQ3ZoCiAgICAgIFk5VnFzeURSQUluUFI5TGIvdVU3Q20xSUVVQmJkVldBeGtnM0ltYW9JMGY3SGdYYlRYTE1aQmxSeFpleHpDSXYKICAgICAgZjUvN0FHRjJiaDVvVExOWEYrT28yK0I3bUtIMzBzQUdvbGIxTlVrNm5Ld0xUQnBzaFpxdnB0R2YxUlZVb1JHegogICAgICBJWG0xT1FwSTZJYlNXenpUMXdrbnI5TWdTOGxtYWJ4TGNUNGZwSGhOZXlxRFRtczhaM2taMjFFY1FYRXpQV0svCiAgICAgIDBzSTRoTHBaZmhNM1A5SGY1MHNBclhSOURJMVRyVS9VY0tmd3JzSVBjVjk4RTZFNzJNdWRCeGlTQjNLbkMvS2wKICAgICAgM2VXb1UrNzRsazZrYVhaMEV5cTNOWVlqY0NuTG1wRGQ1aHNpcDBRbVUvOXJ3b0g5ZXFBT1FDZ3lpR0NTREpyRAogICAgICB2M3BhK2NFQ2dZRUF3OTYrT3dtUVZoUG9SdVRRZGZYeU1YMlZTSEhVRHJJKzd2ZEhoaHdaRjZ1MUJZaE5mZTY0CiAgICAgIGpjVnFDTW5sVlZBaGFRL090VmNXYk55MGI2ZW16YSsrTGpqOGpiNlhGd3NXajhVdEFoNGpIVTJvc09NREs2VlEKICAgICAgQnRDL0JMRUl2NmlyTXNRVTFKMko5ajRGMTc0TjNVK3RvRUtHVEZCWWFpSThmZ1RHTEJndXF6TUNnWUVBN1hnawogICAgICBYeDVrL0N2cjZPTndFajdEU0pKYlJMZkl5SUJ0Zm5pS240T1VBWlRDV0pOdGNzSndidlBLVEJ0K0FmTk1KYjVFCiAgICAgIEhCdWtKQVl4MDRNazlDNEZkQ2RFNU9RaklZQmZNSU5mdzcvakV5aGIrMDRPR2pKNnBuQlByVTVraEU1U1Njc0wKICAgICAgS01BU2FuNnFyeVBOTG9RWVdOTEVrZ205Wk5yWHhvOFY0b3l1em9VQ2dZQjlkeVRydEVpY21zdmkvWmI2dUx5WAogICAgICBMeFo4L1UwVXpPQzdPZks2MlN6Sm1OZXYzNHVqNjFLVW5hdzZUUGwyR0lvT1BtM3Vnd1orWFRISGcrQzVTS1hOCiAgICAgIC9mcm80UGp2YmM3WjhUZlBiM2FXd3JRWCtwS0JWcmRZWmthMXZxRVlBL2NGNGN4bUZUUFdaQXhpRWYvWGo3NXMKICAgICAgTmJESkdYNUpIZjBaeS8wVktiaGJPUUtCZ0dkV084V2tyVjlMSWFyRHBsWmFONUxTRmFOdXNwSUZ5U0FiQm4vcAogICAgICB1ek9BNzUycDhodlpYeUg1TnRRdHRvVFV3aE0rbTliN2RFODAzdVBqRXVhclREWkNqR2xxbVpzUGlOek1ucFRKCiAgICAgIFlPQktWTlNrSCtEb2pKVDNGTVVlOHdEY01GVHFaWjNERDRDR1JISllpd1l0OTRaWG1iRFBTanFrUFBlcjltTVMKICAgICAgdzFNZEFvR0FPOEJsVzQraSt5bnIrQWROTzhJUEpjOUhMQVRPUDUvN1E5ams3bzdDa3owcCttNklzU2NhMHNiUQogICAgICBYUEdwdEhMQWlld1hzUHE4bnJ3NE5DbTI1RXgrZ2szd0IwcjMwNTF3T3pyaGZJdEZVNTBMcUZLSTdFblY0QWpECiAgICAgIDBORHZzRlh3RExpYlNlSTl3Q3NTSTEwRFZveGR2NEoyMDdPL3d0WVloakNWVkhrWStiWT0KICAgICAgLS0tLS1FTkQgUlNBIFBSSVZBVEUgS0VZLS0tLS0KICAgICAgCi0gICBwYXRoOiAvZXRjL3JhbmNoZXIvcmtlMi9jb25maWcueWFtbAogICAgb3duZXI6IHJvb3Q6cm9vdAogICAgcGVybWlzc2lvbnM6ICcwNjQwJwogICAgY29udGVudDogfAogICAgICBjbHVzdGVyLWNpZHI6IDEwLjQ1LjAuMC8xNgogICAgICBkaXNhYmxlLWNsb3VkLWNvbnRyb2xsZXI6IHRydWUKICAgICAgc2VydmljZS1jaWRyOiAxMC40Ni4wLjAvMTYKICAgICAgdGxzLXNhbjoKICAgICAgLSBodHRwczovL2Zvby5jb20KICAgICAgdG9rZW46IDU3ZDkxZTZhMmU4Y2EyYTg1NzhkNTQyOTc5YTI3Y2UwCiAgICAgIAoKCnJ1bmNtZDoKICAtICdjdXJsIC1zZkwgaHR0cHM6Ly9nZXQucmtlMi5pbyB8IElOU1RBTExfUktFMl9WRVJTSU9OPXYxLjMwLjYrcmtlMnIxIHNoIC1zIC0gc2VydmVyJwogIC0gJ3N5c3RlbWN0bCBlbmFibGUgcmtlMi1zZXJ2ZXIuc2VydmljZScKICAtICdzeXN0ZW1jdGwgc3RhcnQgcmtlMi1zZXJ2ZXIuc2VydmljZScKICAtICdta2RpciAtcCAvcnVuL2NsdXN0ZXItYXBpJwogIC0gJ2VjaG8gc3VjY2VzcyA+IC9ydW4vY2x1c3Rlci1hcGkvYm9vdHN0cmFwLXN1Y2Nlc3MuY29tcGxldGUnCg==`) //nolint:lll
)

func GetObjectRef(obj *metav1.ObjectMeta, kind string) *corev1.ObjectReference {
	return &corev1.ObjectReference{
		APIVersion: infrastructurev1alpha1.GroupVersion.String(),
		Kind:       kind,
		Name:       obj.Name,
		Namespace:  obj.Namespace,
		UID:        obj.UID,
	}
}

func NewCluster(namespace, clusterName string) *clusterv1.Cluster {
	cluster := &clusterv1.Cluster{
		TypeMeta: metav1.TypeMeta{},
		ObjectMeta: metav1.ObjectMeta{
			Name:      clusterName,
			Namespace: namespace,
		},
	}
	return cluster
}

func NewIntelCluster(namespace, intelClusterName, providerId string, cluster *clusterv1.Cluster) *infrastructurev1alpha1.IntelCluster { //nolint:lll
	return &infrastructurev1alpha1.IntelCluster{
		TypeMeta: metav1.TypeMeta{},
		ObjectMeta: metav1.ObjectMeta{
			Name:      intelClusterName,
			Namespace: namespace,
			OwnerReferences: []metav1.OwnerReference{
				{
					APIVersion: clusterv1.GroupVersion.String(),
					Kind:       "Cluster",
					Name:       cluster.Name,
					UID:        cluster.UID,
				},
			},
		},
		Spec: infrastructurev1alpha1.IntelClusterSpec{
			ProviderId: providerId,
		},
	}
}

func NewNamespace(name string) *corev1.Namespace {
	return &corev1.Namespace{
		ObjectMeta: metav1.ObjectMeta{
			Name: name,
		},
	}
}
func NewIntelClusterNoSpec(cluster *clusterv1.Cluster) *infrastructurev1alpha1.IntelCluster {
	return &infrastructurev1alpha1.IntelCluster{
		TypeMeta: metav1.TypeMeta{},
		ObjectMeta: metav1.ObjectMeta{
			Name:      cluster.Name,
			Namespace: cluster.Namespace,
			OwnerReferences: []metav1.OwnerReference{
				{
					APIVersion: clusterv1.GroupVersion.String(),
					Kind:       "Cluster",
					Name:       cluster.Name,
					UID:        cluster.UID,
				},
			},
		},
	}
}

func NewMachine(namespace, clusterName, machineName, bootstrapKind string) *clusterv1.Machine {
	bootstrapData := "bootstrap-data"
	machine := &clusterv1.Machine{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Machine",
			APIVersion: clusterv1.GroupVersion.String(),
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      machineName,
			Namespace: namespace,
			Labels: map[string]string{
				clusterv1.ClusterNameLabel:         clusterName,
				clusterv1.MachineControlPlaneLabel: "true",
			},
		},
		Spec: clusterv1.MachineSpec{
			ClusterName: clusterName,
			Bootstrap: clusterv1.Bootstrap{
				ConfigRef: &corev1.ObjectReference{
					Kind: bootstrapKind,
				},
				DataSecretName: &bootstrapData,
			},
		},
	}
	return machine
}

func NewIntelMachine(namespace, intelMachineName string, machine *clusterv1.Machine) *infrastructurev1alpha1.IntelMachine { //nolint:lll
	return &infrastructurev1alpha1.IntelMachine{
		TypeMeta: metav1.TypeMeta{
			Kind:       "IntelMachine",
			APIVersion: infrastructurev1alpha1.GroupVersion.String(),
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      intelMachineName,
			Namespace: namespace,
			OwnerReferences: []metav1.OwnerReference{
				{
					APIVersion: clusterv1.GroupVersion.String(),
					Kind:       "Machine",
					Name:       machine.Name,
					UID:        machine.UID,
				},
			},
			Labels: map[string]string{infrastructurev1alpha1.NodeGUIDKey: ""},
		},
	}
}

func NewIntelMachineBinding(namespace, intelMachineBindingName, nodeGUID, clusterName, machineTemplateName string) *infrastructurev1alpha1.IntelMachineBinding { //nolint:lll
	return &infrastructurev1alpha1.IntelMachineBinding{
		TypeMeta: metav1.TypeMeta{},
		ObjectMeta: metav1.ObjectMeta{
			Name:      intelMachineBindingName,
			Namespace: namespace,
		},
		Spec: infrastructurev1alpha1.IntelMachineBindingSpec{
			NodeGUID:                 nodeGUID,
			ClusterName:              clusterName,
			IntelMachineTemplateName: machineTemplateName,
		},
	}
}

func NewIntelMachineTemplate(namespace, name, parent string) *infrastructurev1alpha1.IntelMachineTemplate { //nolint:lll
	annotations := map[string]string{}
	if parent != "" {
		annotations[clusterv1.TemplateClonedFromNameAnnotation] = parent
	}
	return &infrastructurev1alpha1.IntelMachineTemplate{
		TypeMeta: metav1.TypeMeta{},
		ObjectMeta: metav1.ObjectMeta{
			Name:        name,
			Namespace:   namespace,
			Annotations: annotations,
		},
		Spec: infrastructurev1alpha1.IntelMachineTemplateSpec{},
	}
}

func NewBootstrapSecret(namespace, secretName string) *corev1.Secret {
	value, err := base64.StdEncoding.DecodeString(string(rke2CloudConfig))
	if err != nil {
		panic(err)
	}

	return &corev1.Secret{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Secret",
			APIVersion: "v1",
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      secretName,
			Namespace: namespace,
		},
		Data: map[string][]byte{
			"format": []byte("cloud-config"),
			"value":  value,
		},
	}
}
